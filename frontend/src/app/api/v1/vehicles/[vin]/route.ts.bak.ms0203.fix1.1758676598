// runtime: Node.js (need 'pg')
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from 'next/server';
import crypto from 'node:crypto';

// --- Config ---
const API_VERSION = '1';
const RL_LIMIT_PER_MIN = 60; // 60 rpm
const RL_WINDOW_MS = 60_000;
const ALLOWED_ORIGINS = new Set([
  'https://vinops.online',
  'https://www.vinops.online',
]);

// Simple in-memory rate limiter (per-process)
type RLEntry = { count: number; resetAt: number };
const RL = new Map<string, RLEntry>();

function traceId(): string {
  return crypto.randomBytes(8).toString('hex');
}

function getClientIp(req: NextRequest): string {
  const xf = req.headers.get('x-forwarded-for');
  if (xf) return xf.split(',')[0].trim();
  // As a fallback use a hash of headers to avoid undefined
  return crypto.createHash('sha1').update((req.headers.get('cf-connecting-ip')||'') + (req.headers.get('user-agent')||'')).digest('hex').slice(0,16);
}

function corsHeaders(origin: string | null) {
  const headers: Record<string, string> = {
    'Access-Control-Allow-Methods': 'GET, OPTIONS',
    'Access-Control-Allow-Headers': 'Accept, Accept-Language, Content-Type, If-None-Match',
    'Vary': 'Origin, Accept-Language',
  };
  if (origin && ALLOWED_ORIGINS.has(origin)) {
    headers['Access-Control-Allow-Origin'] = origin;
  }
  return headers;
}

export async function OPTIONS(req: NextRequest) {
  const origin = req.headers.get('origin');
  return new NextResponse(null, { status: 204, headers: corsHeaders(origin) });
}

const VIN_RE = /^[A-HJ-NPR-Z0-9]{11,17}$/;

function normalizeVin(raw: string): string {
  return (raw || '').toUpperCase().trim();
}

async function getDbQueryFn() {
  // Try central DAL first
  try {
    // relative to /api/v1/vehicles/[vin]/route.ts
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const mod = await import('../../../_lib/db');
    const anyMod: any = mod;
    if (anyMod?.query && typeof anyMod.query === 'function') {
      return anyMod.query.bind(anyMod);
    }
    if (anyMod?.default?.query && typeof anyMod.default.query === 'function') {
      return anyMod.default.query.bind(anyMod.default);
    }
    if (anyMod?.getPool && typeof anyMod.getPool === 'function') {
      const pool = anyMod.getPool();
      if (pool?.query) return pool.query.bind(pool);
    }
  } catch (_) {
    // ignore and fallback
  }
  // Fallback: local Pool (read-only usage)
  const { Pool } = await import('pg');
  // @ts-expect-error augment global
  const g: any = globalThis as any;
  if (!g.__vinops_pool) {
    g.__vinops_pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: { rejectUnauthorized: true }, // verify-full expected on server
      max: 5,
      idleTimeoutMillis: 10_000,
    });
  }
  const pool = g.__vinops_pool;
  return pool.query.bind(pool);
}

function rateLimit(req: NextRequest) {
  const now = Date.now();
  const ip = getClientIp(req);
  const ent = RL.get(ip);
  if (!ent || now >= ent.resetAt) {
    RL.set(ip, { count: 1, resetAt: now + RL_WINDOW_MS });
    return { ok: true, remaining: RL_LIMIT_PER_MIN - 1, resetAt: now + RL_WINDOW_MS, limit: RL_LIMIT_PER_MIN };
  }
  if (ent.count >= RL_LIMIT_PER_MIN) {
    return { ok: false, remaining: 0, resetAt: ent.resetAt, limit: RL_LIMIT_PER_MIN };
  }
  ent.count++;
  return { ok: true, remaining: RL_LIMIT_PER_MIN - ent.count, resetAt: ent.resetAt, limit: RL_LIMIT_PER_MIN };
}

function json(data: any, init: number | ResponseInit = 200) {
  const headers = new Headers(
    typeof init === 'number' ? undefined : (init.headers as any)
  );
  headers.set('Content-Type', 'application/json; charset=utf-8');
  return new NextResponse(JSON.stringify(data), typeof init === 'number' ? { status: init, headers } : { ...init, headers });
}

function notFound(trace: string, origin: string | null) {
  return json({ error: { code: 'NOT_FOUND', message: 'VIN not found' }, traceId: trace }, { status: 404, headers: corsHeaders(origin) });
}
function gone(trace: string, origin: string | null) {
  return json({ error: { code: 'SUPPRESSED', message: 'VIN removed/suppressed' }, traceId: trace }, { status: 410, headers: corsHeaders(origin) });
}
function invalid(trace: string, origin: string | null) {
  return json({ error: { code: 'INVALID_VIN', message: 'VIN must be 11â€“17 chars, uppercase, excluding I/O/Q' }, traceId: trace }, { status: 422, headers: corsHeaders(origin) });
}
function tooMany(trace: string, origin: string | null, rl: {limit:number; remaining:number; resetAt:number}) {
  const h = corsHeaders(origin);
  h['Retry-After'] = Math.max(0, Math.ceil((rl.resetAt - Date.now())/1000)).toString();
  h['X-RateLimit-Limit'] = String(rl.limit);
  h['X-RateLimit-Remaining'] = String(rl.remaining);
  h['X-RateLimit-Reset'] = String(Math.floor(rl.resetAt/1000));
  return json({ error: { code: 'RATE_LIMITED', message: 'Too many requests' }, traceId: trace }, { status: 429, headers: h });
}

export async function GET(req: NextRequest, ctx: { params: { vin: string } }) {
  const started = Date.now();
  const trace = traceId();
  const origin = req.headers.get('origin');

  // CORS is applied on all responses
  const rl = rateLimit(req);
  if (!rl.ok) return tooMany(trace, origin, rl);

  const vinRaw = ctx?.params?.vin ?? '';
  const vin = normalizeVin(vinRaw);

  if (!VIN_RE.test(vin)) {
    return invalid(trace, origin);
  }

  try {
    const query = await getDbQueryFn();

    // 1) Vehicle
    const vRes = await query(
      `SELECT vin, make, model, year, body, fuel, transmission, drive, engine, updated_at
       FROM vehicles WHERE vin = $1`,
      [vin],
    );

    if (vRes.rowCount === 0) {
      return notFound(trace, origin);
    }
    const v = vRes.rows[0];

    // 2) Suppress flag (optional column; ignore if not exists)
    let suppressed = false;
    try {
      const sRes = await query(`SELECT is_hidden FROM vehicles WHERE vin = $1`, [vin]);
      if (sRes.rowCount > 0 && sRes.rows[0]?.is_hidden === true) suppressed = true;
    } catch (e: any) {
      // column missing -> treat as not suppressed
      suppressed = false;
    }
    if (suppressed) {
      const res = gone(trace, origin);
      res.headers.set('X-Api-Version', API_VERSION);
      res.headers.set('Vary', 'Origin, Accept-Language');
      return res;
    }

    // 3) Current lot (latest auction datetime or latest id)
    const lRes = await query(
      `SELECT id AS lot_id, status, site_code, city, region, country,
              auction_datetime_utc, retail_value_usd
         FROM lots
        WHERE vin = $1
        ORDER BY auction_datetime_utc DESC NULLS LAST, id DESC
        LIMIT 1`,
      [vin],
    );
    const lot = lRes.rowCount ? lRes.rows[0] : null;

    // 4) Images meta
    const iRes = await query(
      `SELECT COUNT(*)::int AS image_count,
              MIN(source_url) FILTER (WHERE source_url IS NOT NULL) AS primary_image_url
         FROM images WHERE vin = $1`,
      [vin],
    );
    const img = iRes.rowCount ? iRes.rows[0] : { image_count: 0, primary_image_url: null };

    // 5) Sale events (last 10)
    const seRes = await query(
      `SELECT id, lot_id, status, sale_date, final_bid_usd, currency
         FROM sale_events
        WHERE vin = $1
        ORDER BY sale_date DESC NULLS LAST, id DESC
        LIMIT 10`,
      [vin],
    );
    const saleEvents = seRes.rows ?? [];

    // 6) Build DTO (flatten current lot fields as in OpenAPI)
    const dto: any = {
      vin: v.vin,
      year: v.year ?? null,
      make: v.make ?? null,
      model: v.model ?? null,
      trim: null,
      body: v.body ?? null,
      fuel: v.fuel ?? null,
      transmission: v.transmission ?? null,
      drive: v.drive ?? null,
      engine: v.engine ?? null,

      lotId: lot?.lot_id ?? null,
      status: lot?.status ?? null,
      siteCode: lot?.site_code ?? null,
      city: lot?.city ?? null,
      region: lot?.region ?? null,
      country: lot?.country ?? null,
      auctionDateTimeUtc: lot?.auction_datetime_utc ? new Date(lot.auction_datetime_utc).toISOString() : null,
      estRetailValueUsd: lot?.retail_value_usd ?? null,
      runsDrives: null,
      hasKeys: null,

      primaryImageUrl: img?.primary_image_url ?? null,
      imageCount: img?.image_count ?? 0,

      saleEvents: saleEvents.map((s: any) => ({
        id: s.id,
        lotId: s.lot_id,
        status: s.status,
        saleDate: s.sale_date ? new Date(s.sale_date).toISOString() : null,
        finalBidUsd: s.final_bid_usd ?? null,
        currency: s.currency ?? null,
      })),
    };

    const body = JSON.stringify(dto);
    const etag = 'W/"' + crypto.createHash('sha1').update(body).digest('hex') + '"';
    if (req.headers.get('if-none-match') === etag) {
      const h = corsHeaders(origin);
      h['Cache-Control'] = 'public, max-age=60, stale-while-revalidate=300';
      h['ETag'] = etag;
      h['X-Api-Version'] = API_VERSION;
      h['Vary'] = 'Origin, Accept-Language';
      return new NextResponse(null, { status: 304, headers: h });
    }

    const headers = corsHeaders(origin);
    headers['Cache-Control'] = 'public, max-age=60, stale-while-revalidate=300';
    headers['ETag'] = etag;
    headers['X-Api-Version'] = API_VERSION;
    headers['Vary'] = 'Origin, Accept-Language';
    headers['Content-Type'] = 'application/json; charset=utf-8';

    const latency = Date.now() - started;
    headers['Server-Timing'] = `db;desc="aggregate";dur=${latency}`;

    return new NextResponse(body, { status: 200, headers });
  } catch (err: any) {
    const origin = req.headers.get('origin');
    const h = corsHeaders(origin);
    h['X-Api-Version'] = API_VERSION;
    return json({ error: { code: 'INTERNAL', message: 'Internal error' }, traceId: traceId() }, { status: 500, headers: h });
  }
}
