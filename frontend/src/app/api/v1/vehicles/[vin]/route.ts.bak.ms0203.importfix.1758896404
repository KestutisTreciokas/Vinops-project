import { NextRequest, NextResponse } from 'next/server';
import crypto from 'node:crypto';
import { query, getPool } from '../../_lib/db';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

const API_VERSION = '1';
const ORIGINS = new Set(['https://vinops.online','https://www.vinops.online']);
const RL_LIMIT = 60; // rpm
const rl: Map<string, { ts: number; cnt: number }> = (globalThis as any).__vinops_rl || new Map();
(globalThis as any).__vinops_rl = rl;

function nowSec(){ return Math.floor(Date.now()/1000); }
function clientIp(req: NextRequest){
  return req.headers.get('cf-connecting-ip') || req.headers.get('x-forwarded-for') || 'anon';
}
function cors(origin: string|null){
  const h: Record<string,string> = {
    'Access-Control-Allow-Methods': 'GET,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, If-None-Match, If-Modified-Since, Accept-Language',
    'Vary': 'Origin, Accept-Language',
    'X-Api-Version': API_VERSION
  };
  if (origin && ORIGINS.has(origin)) h['Access-Control-Allow-Origin'] = origin;
  return h;
}
function normalizeVin(v: string){
  const up = (v||'').toUpperCase().trim();
  if (up.length < 11 || up.length > 17) return { ok:false, reason:'LEN' as const };
  if (!/^[A-Z0-9]+$/.test(up)) return { ok:false, reason:'CHAR' as const };
  if (up.length === 17 && /[IOQ]/.test(up)) return { ok:false, reason:'IOQ' as const };
  return { ok:true, vin: up };
}
function stableStringify(obj: any): string {
  const seen = new WeakSet();
  const sortKeys = (x: any): any => {
    if (x && typeof x === 'object') {
      if (seen.has(x)) return null;
      seen.add(x);
      if (Array.isArray(x)) return x.map(sortKeys);
      return Object.keys(x).sort().reduce((acc: any, k) => { acc[k] = sortKeys(x[k]); return acc; }, {});
    }
    return x;
  };
  return JSON.stringify(sortKeys(obj));
}
function weakETagFrom(obj: unknown) {
  const s = stableStringify(obj);
  const h = crypto.createHash('sha1').update(s).digest('hex');
  return `W/"${h}"`;
}

export async function OPTIONS(req: NextRequest) {
  const origin = req.headers.get('origin');
  return new NextResponse(null, { status: 204, headers: cors(origin) });
}

async function qSafe<T=any>(sql: string, params: any[]) {
  try { return await query<T>(sql, params); }
  catch (e: any) {
    // relation missing etc — treat as empty
    if (e?.code === '42P01') return { rows: [], rowCount: 0 } as any;
    throw e;
  }
}

export async function GET(req: NextRequest, ctx: { params: { vin: string } }) {
  const origin = req.headers.get('origin');
  const headers = cors(origin);

  // Rate limit (per IP, 60 rpm)
  const ip = clientIp(req);
  const b = rl.get(ip) || { ts: nowSec(), cnt: 0 };
  if (nowSec() - b.ts >= 60) { b.ts = nowSec(); b.cnt = 0; }
  b.cnt += 1; rl.set(ip, b);
  headers['X-RateLimit-Limit'] = `${RL_LIMIT}`;
  headers['X-RateLimit-Remaining'] = `${Math.max(0, RL_LIMIT - b.cnt)}`;
  headers['X-RateLimit-Reset'] = `${b.ts + 60}`;
  if (b.cnt > RL_LIMIT) {
    return NextResponse.json({ error:{ code:'RATE_LIMIT', message:'Too many requests' }}, { status: 429, headers });
  }

  const n = normalizeVin(ctx.params.vin);
  if (!n.ok) {
    headers['Cache-Control'] = 'no-store, must-revalidate';
    return NextResponse.json({ error:{ code:'INVALID_VIN', message:'VIN must be 11–17 uppercase, excluding I/O/Q' }}, { status: 422, headers });
  }
  const vin = n.vin;

  // DEV overlay for suppressed VIN (doesn't affect prod)
  if ((process.env.DEV_SUPPRESS_VIN || '').split(',').map(s => s.trim()).includes(vin)) {
    headers['Cache-Control'] = 'no-store, must-revalidate';
    return NextResponse.json({ status: 'suppressed' }, { status: 410, headers });
  }

  // Fetch vehicle (try core.vehicles then public.vehicles)
  let v = await qSafe<{vin:string,year:number|null,make:string|null,model:string|null,trim:string|null,updated_at:string|null}>(
    `select vin, year, make, model, trim, updated_at from core.vehicles where vin = $1`, [vin]
  );
  if (v.rowCount === 0) {
    v = await qSafe(
      `select vin, year, make, model, trim, updated_at from public.vehicles where vin = $1`, [vin]
    );
  }
  if (v.rowCount === 0) {
    headers['Cache-Control'] = 'no-store, must-revalidate';
    return NextResponse.json({ error:{ code:'NOT_FOUND', message:'VIN not found' }}, { status: 404, headers });
  }
  const vehicle = v.rows[0];

  // Optional aggregates (ignore missing relations)
  const lot = await qSafe(
    `select lot_id, source, status, auction_datetime_utc, est_retail_value
       from core.lots where vin=$1
       order by coalesce(auction_datetime_utc, now()) desc, lot_id desc
       limit 1`, [vin]
  );

  const images = await qSafe(
    `select lot_id, seq, variant, url from core.images
       where vin=$1 and variant in ('thumb','md','xl')
       order by seq asc limit 100`, [vin]
  );

  const sales = await qSafe(
    `select sale_date, status, final_bid_usd
       from core.sale_events
       where vin=$1
       order by sale_date desc
       limit 10`, [vin]
  );

  const dto = {
    vin,
    vehicle: {
      year: vehicle.year ?? null,
      make: vehicle.make ?? null,
      model: vehicle.model ?? null,
      trim: vehicle.trim ?? null,
      updatedAt: vehicle.updated_at ?? null,
    },
    currentLot: lot.rowCount ? lot.rows[0] : null,
    images: images.rows,
    saleEvents: sales.rows,
  };

  // ETag / Last-Modified / Cache
  const etag = weakETagFrom(dto);
  const ifNoneMatch = req.headers.get('if-none-match');
  const lastMod = vehicle.updated_at ? new Date(vehicle.updated_at) : null;
  if (ifNoneMatch && ifNoneMatch === etag) {
    const h = { ...headers,
      'ETag': etag,
      ...(lastMod ? { 'Last-Modified': lastMod.toUTCString() } : {}),
      'Cache-Control': 'public, max-age=60, stale-while-revalidate=300'
    };
    return new NextResponse(null, { status: 304, headers: h });
  }

  const outHeaders = {
    ...headers,
    'Content-Type': 'application/json',
    'Cache-Control': 'public, max-age=60, stale-while-revalidate=300',
    'ETag': etag,
    ...(lastMod ? { 'Last-Modified': lastMod.toUTCString() } : {})
  };
  return NextResponse.json(dto, { status: 200, headers: outHeaders });
}
