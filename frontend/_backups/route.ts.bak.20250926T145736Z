import { NextRequest, NextResponse } from 'next/server'
import crypto from 'node:crypto'
import { query } from '../../_lib/db'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

const API_VERSION = '1'
const ORIGINS = new Set(['https://vinops.online','https://www.vinops.online'])
const RL_LIMIT = 60
const rl: Map<string, { ts: number; cnt: number }> = (globalThis as any).__vinops_rl || new Map()
;(globalThis as any).__vinops_rl = rl

function nowSec(){ return Math.floor(Date.now()/1000) }
function clientIp(req: NextRequest){
  return req.headers.get('cf-connecting-ip') || req.headers.get('x-forwarded-for') || 'anon'
}
function cors(origin: string|null){
  const h: Record<string,string> = {
    'Access-Control-Allow-Methods': 'GET,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, If-None-Match, If-Modified-Since, Accept-Language',
    'Vary': 'Origin, Accept-Language',
    'X-Api-Version': API_VERSION
  }
  if (origin && ORIGINS.has(origin)) h['Access-Control-Allow-Origin'] = origin
  return h
}
function normalizeVin(v: string){
  const up = (v||'').toUpperCase().trim()
  if (up.length < 11 || up.length > 17) return { ok:false, reason:'LEN' as const }
  if (!/^[A-Z0-9]+$/.test(up)) return { ok:false, reason:'CHAR' as const }
  if (up.length === 17 && /[IOQ]/.test(up)) return { ok:false, reason:'IOQ' as const }
  return { ok:true, vin: up }
}
function stableStringify(obj: any): string {
  const seen = new WeakSet()
  const sortKeys = (x: any): any => {
    if (x && typeof x === 'object') {
      if (seen.has(x)) return null
      seen.add(x)
      if (Array.isArray(x)) return x.map(sortKeys)
      return Object.keys(x).sort().reduce((acc: any, k) => { acc[k] = sortKeys(x[k]); return acc }, {})
    }
    return x
  }
  return JSON.stringify(sortKeys(obj))
}
function weakETagFrom(obj: unknown) {
  const s = stableStringify(obj)
  const h = crypto.createHash('sha1').update(s).digest('hex')
  return `W/"${h}"`
}

export async function OPTIONS(req: NextRequest) {
  const origin = req.headers.get('origin')
  return new NextResponse(null, { status: 204, headers: cors(origin) })
}

export async function GET(req: NextRequest, ctx: { params: { vin: string } }) {
  const origin = req.headers.get('origin')
  const headers = cors(origin)

  // Rate limit (per IP, 60 rpm)
  const ip = clientIp(req)
  const b = rl.get(ip) || { ts: nowSec(), cnt: 0 }
  if (nowSec() - b.ts >= 60) { b.ts = nowSec(); b.cnt = 0 }
  b.cnt += 1; rl.set(ip, b)
  headers['X-RateLimit-Limit'] = `${RL_LIMIT}`
  headers['X-RateLimit-Remaining'] = `${Math.max(0, RL_LIMIT - b.cnt)}`
  headers['X-RateLimit-Reset'] = `${b.ts + 60}`
  if (b.cnt > RL_LIMIT) {
    return NextResponse.json({ error:{ code:'RATE_LIMIT', message:'Too many requests' }}, { status: 429, headers })
  }

  const n = normalizeVin(ctx.params.vin)
  if (!n.ok) {
    headers['Cache-Control'] = 'no-store, must-revalidate'
    return NextResponse.json(
      { error:{ code:'INVALID_VIN', message:'VIN must be 11–17 uppercase, excluding I/O/Q' } },
      { status: 422, headers }
    )
  }
  const vin = n.vin
  const traceId = crypto.randomUUID()
  try {
    // Агрегированный запрос (read-only); ограничиваем историю последними 10
    const sql = `
      SELECT v.vin, v.year, v.make, v.model, v.trim, v.updated_at, COALESCE(v.is_hidden,false) AS is_hidden,
        (
          SELECT to_json(l) FROM core.lots l
          WHERE l.vin = v.vin
          ORDER BY l.auction_datetime_utc DESC NULLS LAST
          LIMIT 1
        ) AS current_lot,
        COALESCE((
          SELECT json_agg(json_build_object('seq',i.seq,'variant',i.variant,'url',i.url) ORDER BY i.seq)
          FROM core.images i
          WHERE i.vin = v.vin AND i.variant IN ('thumb','md','xl')
        ), '[]'::json) AS images,
        COALESCE((
          SELECT json_agg(json_build_object('sale_date',s.sale_date,'status',s.status,'final_bid_usd',s.final_bid_usd)
                          ORDER BY s.sale_date DESC LIMIT 10)
          FROM core.sale_events s WHERE s.vin = v.vin
        ), '[]'::json) AS sale_events
      FROM core.vehicles v
      WHERE v.vin = $1
      LIMIT 1
    `
    const { rows } = await query<any>(sql, [vin], { traceId })
    if (rows.length === 0) {
      headers['Cache-Control'] = 'no-store, must-revalidate'
      return NextResponse.json({ error:{ code:'NOT_FOUND', message:'VIN not found' }}, { status: 404, headers })
    }
    const row = rows[0]
    if (row.is_hidden === true) {
      headers['Cache-Control'] = 'no-store, must-revalidate'
      return NextResponse.json({ status:'suppressed' }, { status: 410, headers })
    }

    const dto = {
      vin: row.vin,
      year: row.year, make: row.make, model: row.model, trim: row.trim,
      currentLot: row.current_lot || null,
      images: Array.isArray(row.images) ? row.images : [],
      saleEvents: Array.isArray(row.sale_events) ? row.sale_events : [],
      updatedAt: row.updated_at || null,
    }

    // Кэш-заголовки
    const etag = weakETagFrom(dto)
    const ims = req.headers.get('if-modified-since')
    const ifNoneMatch = req.headers.get('if-none-match')
    const lastModISO = dto.updatedAt ? new Date(dto.updatedAt).toUTCString() : undefined

    headers['Cache-Control'] = 'public, max-age=60, stale-while-revalidate=300'
    headers['ETag'] = etag
    if (lastModISO) headers['Last-Modified'] = lastModISO

    if (ifNoneMatch && ifNoneMatch === etag) {
      return new NextResponse(null, { status: 304, headers })
    }
    if (ims && lastModISO && Date.parse(ims) >= Date.parse(lastModISO)) {
      return new NextResponse(null, { status: 304, headers })
    }

    return NextResponse.json(dto, { status: 200, headers })
  } catch (e: any) {
    headers['Cache-Control'] = 'no-store, must-revalidate'
    return NextResponse.json({ error:{ code:'INTERNAL', message:'Internal error' }}, { status: 500, headers })
  }
}
