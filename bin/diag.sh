#!/usr/bin/env bash
# bin/diag.sh — Read-only диагностика проекта и окружения
# Создаёт снимок состояния в context/context-YYYY-MM-DD_HHMMSS-Europe_Warsaw/ и пакует в .tar.gz
# Политики: без разрушающих действий; падать нельзя (всегда exit 0); секреты маскируются в отчётах.

###############################################################################
# Глобальные установки (без 'set -e', мы не падаем на ошибках)
###############################################################################
umask 022
export LC_ALL=C
export LANG=C
TZ_WARS=Europe/Warsaw
NOW_LOCAL="$(date '+%Y-%m-%d %H:%M')"
NOW_WARS="$(TZ="$TZ_WARS" date '+%Y-%m-%d %H:%M')"
STAMP="$(TZ="$TZ_WARS" date '+%Y-%m-%d_%H%M%S')-Europe_Warsaw"
EXIT_CODE=0

###############################################################################
# Параметры
###############################################################################
REPO=""
HOST=""
LOGS_TAIL=300
OUT_DIR=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --repo) REPO="$2"; shift 2 ;;
    --host) HOST="$2"; shift 2 ;;
    --logs) LOGS_TAIL="$2"; shift 2 ;;
    --out)  OUT_DIR="$2"; shift 2 ;;
    *) echo "WARN: unknown arg: $1" >&2; shift ;;
  esac
done

###############################################################################
# Утилиты
###############################################################################
info(){ echo "[INFO] $*" >&2; }
warn(){ echo "[WARN] $*" >&2; }

# Безопасный раннер (не рушит процесс), пишет в файл, добавляет шапку с датой/ТЗ
run_to_file(){
  local outfile="$1"; shift
  {
    echo "### cmd: $*"
    echo "### at:  $(date '+%Y-%m-%d %H:%M')  local | $(TZ="$TZ_WARS" date '+%Y-%m-%d %H:%M')  $TZ_WARS"
    "$@" 2>&1 || echo "!!! command failed (non-fatal)"
  } > "$outfile"
}

# Сбор всех docker-compose*.yml в корне репо
compose_args_from_repo(){
  local repo="$1"
  local args=()
  local found=0
  while IFS= read -r f; do
    [[ -n "$f" ]] || continue
    args+=("-f" "$f")
    found=1
  done < <(cd "$repo" 2>/dev/null && ls -1 docker-compose*.yml 2>/dev/null || true)
  if [[ $found -eq 0 ]]; then
    # нет файлов — вернём пустой список, docker compose сам попробует дефолты
    :
  fi
  printf "%s " "${args[@]}"
}

# Маскирование значений в парах KEY=VALUE (используется при публикации env)
mask_keyvals(){
  # Маскируем ВСЕ значения (по заданию для env в инспекциях)
  sed -E 's#^([A-Za-z0-9_]+)=.*#\1=***#'
}

# Быстрая проверка статуса HTTP (код + заголовки) и размера тела
http_probe(){
  local base="$1"
  local path="$2"
  local outdir="$3"
  local safe_url="${base%/}${path}"
  # HEAD
  curl -ksSI "$safe_url" > "${outdir}/HEAD_${path//\//_}.txt" 2>&1 || true
  # GET размер
  local size; size="$(curl -ksS "$safe_url" -o /dev/null -w '%{size_download}' 2>/dev/null || echo 0)"
  echo "size_bytes: $size" > "${outdir}/SIZE_${path//\//_}.txt"
}

# Нормализованная печать “UNKNOWN: как проверить”
unknown_note(){
  local what="$1"; local how="$2"
  echo "- UNKNOWN: ${what}"
  echo "  How to check: ${how}"
}

###############################################################################
# Автодетект корня репозитория и выходной директории
###############################################################################
if [[ -z "$REPO" ]]; then
  if git rev-parse --show-toplevel >/dev/null 2>&1; then
    REPO="$(git rev-parse --show-toplevel 2>/dev/null)"
  else
    REPO="$PWD"
    warn "git root not found; using PWD: $REPO"
  fi
fi

if [[ -z "$OUT_DIR" ]]; then
  OUT_DIR="$REPO/context"
fi
mkdir -p "$OUT_DIR" || true

REPORT_DIR="$OUT_DIR/context-${STAMP}"
mkdir -p "$REPORT_DIR" || true

###############################################################################
# README
###############################################################################
cat > "$REPORT_DIR/README.txt" <<README_EOF
Snapshot generated by bin/diag.sh
Local time:        $NOW_LOCAL
Europe/Warsaw:     $NOW_WARS
Repo root:         $REPO
Host (target):     ${HOST:-UNKNOWN}
Logs tail (lines): $LOGS_TAIL

All files are read-only snapshots for handover.
README_EOF

###############################################################################
# 00. OS / Host
###############################################################################
mkdir -p "$REPORT_DIR/00_os_host"
run_to_file "$REPORT_DIR/00_os_host/lsb_release.txt" bash -lc "lsb_release -a 2>/dev/null || cat /etc/os-release 2>/dev/null || uname -a"
run_to_file "$REPORT_DIR/00_os_host/uname.txt"        uname -a
run_to_file "$REPORT_DIR/00_os_host/lscpu.txt"        lscpu
run_to_file "$REPORT_DIR/00_os_host/free.txt"         free -h
run_to_file "$REPORT_DIR/00_os_host/df.txt"           df -h
{
  echo "Local:        $(date '+%Y-%m-%d %H:%M')"
  echo "Europe/Warsaw: $(TZ="$TZ_WARS" date '+%Y-%m-%d %H:%M')"
} > "$REPORT_DIR/00_os_host/time.txt"

###############################################################################
# 01. Git
###############################################################################
mkdir -p "$REPORT_DIR/01_git"
( cd "$REPO" 2>/dev/null \
  && { git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "UNKNOWN_BRANCH"; } \
) > "$REPORT_DIR/01_git/branch.txt" 2>&1
( cd "$REPO" 2>/dev/null \
  && git log --oneline -n 20 2>/dev/null || true \
) > "$REPORT_DIR/01_git/last_commits.txt"
( cd "$REPO" 2>/dev/null && git status -s 2>/dev/null || true ) > "$REPORT_DIR/01_git/status.txt"
( cd "$REPO" 2>/dev/null && git tag -l 2>/dev/null || true ) > "$REPORT_DIR/01_git/tags.txt"
( cd "$REPO" 2>/dev/null && git remote -v 2>/dev/null || true ) > "$REPORT_DIR/01_git/remotes.txt"

###############################################################################
# 02. Repo layout (и участие в сборке)
###############################################################################
mkdir -p "$REPORT_DIR/02_repo_layout"
LAYOUT_FILE="$REPORT_DIR/02_repo_layout/layout.txt"
{
  echo "# Tree (depth 3):"
  (cd "$REPO" 2>/dev/null && find . -maxdepth 3 -type d \( -path "./.git" -o -path "./node_modules" \) -prune -o -type d -print | sed 's#^\./##' | sort)
  echo
  echo "# Participation in build (heuristics via compose & next.config.*):"
  # Соберём список контекстов сборки из compose
  COMPOSE_ARGS=( $(compose_args_from_repo "$REPO") )
  if docker compose "${COMPOSE_ARGS[@]}" config >/dev/null 2>&1; then
    docker compose "${COMPOSE_ARGS[@]}" config 2>/dev/null | awk '
      $1=="services:" { in=1; next }
      in && $1~/^[a-zA-Z0-9_-]+:$/ { svc=$1; gsub(":","",svc) }
      in && $1=="build:" { build=1 }
      in && build && $1=="context:" { ctx=$2; gsub("\"","",ctx); gsub("'\'","",ctx); print "service="svc"  build_context="ctx; build=0 }
    ' || true
  else
    echo "UNKNOWN: docker compose config failed"
  fi
  # next.config.* присутствует?
  if ls "$REPO"/frontend/next.config.* >/dev/null 2>&1; then
    echo "frontend participates (next.config.* present)"
  fi
} > "$LAYOUT_FILE"

###############################################################################
# 03. Node/JS toolchain
###############################################################################
mkdir -p "$REPORT_DIR/03_node_js"
run_to_file "$REPORT_DIR/03_node_js/node.txt"  node -v
run_to_file "$REPORT_DIR/03_node_js/npm.txt"   npm -v
run_to_file "$REPORT_DIR/03_node_js/pnpm.txt"  sh -lc "pnpm -v"      # may fail
run_to_file "$REPORT_DIR/03_node_js/yarn.txt"  sh -lc "yarn -v"      # may fail
run_to_file "$REPORT_DIR/03_node_js/npx.txt"   npx --version
run_to_file "$REPORT_DIR/03_node_js/next.txt"  sh -lc "next -v"      # may fail

###############################################################################
# 04. Docker / Compose
###############################################################################
mkdir -p "$REPORT_DIR/04_docker"
run_to_file "$REPORT_DIR/04_docker/docker_version.txt"        docker version
run_to_file "$REPORT_DIR/04_docker/docker_compose_version.txt" docker compose version
COMPOSE_ARGS=( $(compose_args_from_repo "$REPO") )
run_to_file "$REPORT_DIR/04_docker/compose_config.yaml"       docker compose "${COMPOSE_ARGS[@]}" config
run_to_file "$REPORT_DIR/04_docker/compose_ps.txt"            docker compose "${COMPOSE_ARGS[@]}" ps
run_to_file "$REPORT_DIR/04_docker/images.txt"                sh -lc 'docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"'
run_to_file "$REPORT_DIR/04_docker/ports_listen.txt"          sh -lc "ss -tulpn | grep LISTEN || true"

###############################################################################
# 05. Container inspections (env keys masked)
###############################################################################
mkdir -p "$REPORT_DIR/05_containers"
# Определим сервисы и их роль
SERVICES="$(docker compose "${COMPOSE_ARGS[@]}" ps --services 2>/dev/null | tr -s ' ' | tr -d '\r' || true)"
ROLE_WEB=""; ROLE_DB=""; ROLE_PROXY=""
for s in $SERVICES; do
  if [[ -z "$ROLE_WEB"   && "$s" =~ (web|app|frontend) ]]; then ROLE_WEB="$s"; fi
  if [[ -z "$ROLE_DB"    && "$s" =~ (db|postgres)      ]]; then ROLE_DB="$s"; fi
  if [[ -z "$ROLE_PROXY" && "$s" =~ (proxy|caddy|nginx) ]]; then ROLE_PROXY="$s"; fi
done

for role in WEB DB PROXY; do
  svc_var="ROLE_${role}"
  svc="${!svc_var}"
  [[ -n "$svc" ]] || continue
  cid="$(docker compose "${COMPOSE_ARGS[@]}" ps -q "$svc" 2>/dev/null || true)"
  if [[ -n "$cid" ]]; then
    {
      echo "# docker inspect (names/ids)"
      docker inspect -f 'Name={{.Name}} Id={{.Id}} Image={{.Config.Image}}' "$cid" 2>/dev/null || true
      echo
      echo "# Env (values masked)"
      docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' "$cid" 2>/dev/null \
        | mask_keyvals || true
      echo
      echo "# Ports"
      docker inspect -f '{{json .NetworkSettings.Ports}}' "$cid" 2>/dev/null || true
    } > "$REPORT_DIR/05_containers/${role,,}_${svc}.txt"
  fi
done

###############################################################################
# 06. Next.js / SSR артефакты
###############################################################################
mkdir -p "$REPORT_DIR/06_next_ssr"
FRONT="$REPO/frontend"
if [[ -d "$FRONT" ]]; then
  run_to_file "$REPORT_DIR/06_next_ssr/tree_app_paths.txt"   sh -lc "cd '$FRONT' && find src/app -type f \\( -name 'page.*' -o -name 'route.*' -o -name 'layout.*' \\) | sort"
  run_to_file "$REPORT_DIR/06_next_ssr/.next_presence.txt"   sh -lc "cd '$FRONT' && ls -la .next 2>/dev/null || echo 'NO .next (build artifact not found)'"
  run_to_file "$REPORT_DIR/06_next_ssr/.next_sizes.txt"      sh -lc "cd '$FRONT' && du -sh .next 2>/dev/null || true"
  run_to_file "$REPORT_DIR/06_next_ssr/server_app.txt"       sh -lc "cd '$FRONT' && ls -la .next/server/app 2>/dev/null || echo 'NO .next/server/app'"
  run_to_file "$REPORT_DIR/06_next_ssr/manifests.txt"        sh -lc "cd '$FRONT' && ls -la .next/server/app-paths-manifest.json 2>/dev/null || echo 'NO app-paths-manifest.json'"
else
  echo "frontend dir not found" > "$REPORT_DIR/06_next_ssr/NOTICE.txt"
fi

###############################################################################
# 07. Public Endpoints (если хост известен/детектирован)
###############################################################################
# Детект хоста из исходников, если не задан: ищем 'https://vinops.online'
if [[ -z "$HOST" ]]; then
  if grep -R "https://vinops.online" "$REPO" >/dev/null 2>&1; then
    HOST="https://vinops.online"
  fi
fi

mkdir -p "$REPORT_DIR/07_endpoints"
if [[ -n "$HOST" ]]; then
  ENDPOINTS=( "/" "/health" "/robots.txt" "/sitemap.xml" "/sitemaps/vin.xml" "/sitemaps/vin/en-0.xml" "/sitemaps/vin/ru-0.xml" "/en" "/ru" )
  for p in "${ENDPOINTS[@]}"; do
    http_probe "$HOST" "$p" "$REPORT_DIR/07_endpoints"
  done
else
  unknown_note "Public host URL" "Run: ./bin/diag.sh --host https://vinops.online" > "$REPORT_DIR/07_endpoints/UNKNOWN.txt"
fi

###############################################################################
# 08. SEO snapshot
###############################################################################
mkdir -p "$REPORT_DIR/08_seo"
if [[ -n "$HOST" ]]; then
  run_to_file "$REPORT_DIR/08_seo/robots.txt"     curl -ksS "${HOST%/}/robots.txt"
  run_to_file "$REPORT_DIR/08_seo/sitemap.xml"    curl -ksSI "${HOST%/}/sitemap.xml"
  # Главная EN для json-ld + canonical/hreflang
  HTML_TMP="$REPORT_DIR/08_seo/home_en.html"
  curl -ksS "${HOST%/}/en" > "$HTML_TMP" 2>/dev/null || true
  grep -i 'application/ld+json' "$HTML_TMP"    > "$REPORT_DIR/08_seo/jsonld_hits.txt" 2>/dev/null || true
  grep -Ei '<link[^>]+rel="(canonical|alternate)"' "$HTML_TMP" > "$REPORT_DIR/08_seo/links_rel.txt" 2>/dev/null || true
else
  unknown_note "SEO endpoints (robots/sitemap/json-ld)" "Provide --host and re-run." > "$REPORT_DIR/08_seo/UNKNOWN.txt"
fi

###############################################################################
# 09. Static/CDN
###############################################################################
mkdir -p "$REPORT_DIR/09_static"
if [[ -d "$REPO/public" ]]; then
  (cd "$REPO/public" && find . -type f | sed 's#^\./##' | head -n 200) > "$REPORT_DIR/09_static/public_inventory.txt"
  if [[ -n "$HOST" ]]; then
    # Выборочно попробуем несколько типичных файлов (если существуют локально)
    for f in icon.svg favicon.ico robots.txt "svg/brand/property-1-brand-theme-light-size-56.svg"; do
      if [[ -f "$REPO/public/$f" ]]; then
        http_probe "$HOST" "/$f" "$REPORT_DIR/09_static"
      fi
    done
  fi
else
  echo "No public/ directory in repo" > "$REPORT_DIR/09_static/NOTICE.txt"
fi

###############################################################################
# 10. Database (Postgres, только read-only инвентарь)
###############################################################################
mkdir -p "$REPORT_DIR/10_db"
DB_SVC=""
for s in $SERVICES; do
  if [[ "$s" =~ (db|postgres) ]]; then DB_SVC="$s"; break; fi
done

if [[ -n "$DB_SVC" ]]; then
  # Попытаемся вытащить имя БД и пользователя из env контейнера (значения НЕ логируем)
  DB_USER="$(docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" sh -lc 'echo "${POSTGRES_USER:-postgres}"' 2>/dev/null || echo postgres)"
  DB_NAME="$(docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" sh -lc 'echo "${POSTGRES_DB:-postgres}"' 2>/dev/null || echo postgres)"
  # \conninfo
  run_to_file "$REPORT_DIR/10_db/conninfo.txt" docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" psql -U "$DB_USER" -d "$DB_NAME" -c '\conninfo'
  # Схемы/таблицы
  run_to_file "$REPORT_DIR/10_db/tables.txt"   docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" psql -U "$DB_USER" -d "$DB_NAME" -c '\dt *.*'
  # Размеры таблиц (топ 100)
  run_to_file "$REPORT_DIR/10_db/sizes.txt"    docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" psql -U "$DB_USER" -d "$DB_NAME" -c "SELECT schemaname||'.'||relname AS rel, pg_total_relation_size(c.oid) AS bytes FROM pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace WHERE relkind='r' ORDER BY 2 DESC LIMIT 100;"
  # Активные подключения (агрегировано)
  run_to_file "$REPORT_DIR/10_db/connections.txt" docker compose "${COMPOSE_ARGS[@]}" exec -T "$DB_SVC" psql -U "$DB_USER" -d "$DB_NAME" -c "SELECT state, count(*) FROM pg_stat_activity GROUP BY state;"
else
  unknown_note "Postgres container/service" "Check: docker compose ps --services | grep -E 'db|postgres'." > "$REPORT_DIR/10_db/UNKNOWN.txt"
fi

###############################################################################
# 11. ETL / Jobs / Cron (инвентарь)
###############################################################################
mkdir -p "$REPORT_DIR/11_jobs"
run_to_file "$REPORT_DIR/11_jobs/repo_cron_grep.txt" sh -lc "cd '$REPO' && grep -RIl --line-number -E '(cron|crontab|systemd|schedule|node-cron)' || true"
run_to_file "$REPORT_DIR/11_jobs/repo_dirs.txt"      sh -lc "cd '$REPO' && ls -la jobs collector scripts 2>/dev/null || true"

###############################################################################
# 12. Logs (docker compose logs --tail N)
###############################################################################
mkdir -p "$REPORT_DIR/12_logs"
for role in WEB DB PROXY; do
  svc_var="ROLE_${role}"
  svc="${!svc_var}"
  if [[ -n "$svc" ]]; then
    run_to_file "$REPORT_DIR/12_logs/${role,,}_${svc}.log" docker compose "${COMPOSE_ARGS[@]}" logs --tail "$LOGS_TAIL" "$svc"
  fi
done

###############################################################################
# 13. Configs (копии без секретов)
###############################################################################
mkdir -p "$REPORT_DIR/13_configs"
# docker-compose*.yml, Dockerfile*, next.config.*, tsconfig*, package.json, .env*
( cd "$REPO" 2>/dev/null && \
    tar -cf - $(ls -1 docker-compose*.yml 2>/dev/null) 2>/dev/null ) | tar -xf - -C "$REPORT_DIR/13_configs" 2>/dev/null || true
( cd "$REPO" 2>/dev/null && \
    tar -cf - $(ls -1 Dockerfile* 2>/dev/null) 2>/dev/null ) | tar -xf - -C "$REPORT_DIR/13_configs" 2>/dev/null || true
( cd "$REPO/frontend" 2>/dev/null && \
    tar -cf - $(ls -1 next.config.* 2>/dev/null) 2>/dev/null ) | tar -xf - -C "$REPORT_DIR/13_configs" 2>/dev/null || true
( cd "$REPO" 2>/dev/null && \
    tar -cf - $(ls -1 tsconfig* package.json 2>/dev/null) 2>/dev/null ) | tar -xf - -C "$REPORT_DIR/13_configs" 2>/dev/null || true

# .env* → в отчёт кладём ТОЛЬКО ключи с маской
ENV_OUT="$REPORT_DIR/13_configs/env_keys_masked.txt"
{
  for f in "$REPO"/.env "$REPO"/.env.*; do
    [[ -f "$f" ]] || continue
    echo "# $f"
    sed -n 's/^\([A-Za-z0-9_]\+\)=.*/\1=***/p' "$f" || true
    echo
  done
} > "$ENV_OUT"

###############################################################################
# 99. Summary: риски/UNKNOWN
###############################################################################
SUMMARY="$REPORT_DIR/99_summary_risks.txt"
{
  echo "Detected risks / UNKNOWN (auto):"
  # Host unknown
  if [[ -z "$HOST" ]]; then
    unknown_note "Public host URL not detected" "./bin/diag.sh --host https://vinops.online"
  fi
  # .next отсутствует
  if [[ ! -d "$REPO/frontend/.next" ]]; then
    unknown_note "Next.js build artifacts (.next) not found" "Build container produces them; check: ls -la '$REPO/frontend/.next'"
  fi
  # compose config fail?
  if ! docker compose "${COMPOSE_ARGS[@]}" config >/dev/null 2>&1; then
    unknown_note "docker compose config" "Run: docker compose $(compose_args_from_repo "$REPO") config"
  fi
  # Postgres доступ
  if [[ -z "$DB_SVC" ]]; then
    unknown_note "Postgres service not detected" "docker compose ps --services | grep -E 'db|postgres'"
  fi
} > "$SUMMARY"

###############################################################################
# Упаковка архива
###############################################################################
ARCHIVE_PATH="$OUT_DIR/context-${STAMP}.tar.gz"
( cd "$OUT_DIR" 2>/dev/null && tar -czf "context-${STAMP}.tar.gz" "context-${STAMP}" ) || true
ABS_ARCHIVE="$(cd "$(dirname "$ARCHIVE_PATH")" 2>/dev/null && pwd)/$(basename "$ARCHIVE_PATH")"
echo "$ABS_ARCHIVE"

exit $EXIT_CODE
